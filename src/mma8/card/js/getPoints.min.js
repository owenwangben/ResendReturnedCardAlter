var middlePoint = function (t, h, i) { this.x = t, this.y = h, this.index = i }, Point = function (t, h) { this.x = t, this.y = h }, outRange = function (t) { var h = 0 < t.x && t.x < t.width, i = 0 < t.y && t.y < t.height; return !(h && i) }, getLocatePoints = function (t, h) { var i = document.createElement("canvas"); i.width = t.width, i.height = t.height; var e = i.getContext("2d"); e.drawImage(t, 0, 0, i.width, i.height); var a = new HoughTransform(i.width, i.height); a.addPoints(i); for (var n = a.getLines(h), o = [], r = [], s = 0; s < n.length; s++) { var g = n[s], x = g.getPoints(i); if ("" != x) { var y = Math.floor(x.length / 2); x[y].isVert ? o.push(new middlePoint(x[y].x, x[y].y, s)) : r.push(new middlePoint(x[y].x, x[y].y, s)) } } o.sort(function (t, h) { return t.x > h.x ? 1 : t.x < h.x ? -1 : 0 }), r.sort(function (t, h) { return t.y > h.y ? 1 : t.y < h.y ? -1 : 0 }); var u, d; if (o.length >= 2) { try { u = n[o[0].index].getPoints(i) } catch (w) { u = []; for (var f = 0; f < i.height; f++) u.push(new Point(10, f)) } try { d = n[o[o.length - 1].index].getPoints(i) } catch (w) { d = []; for (var f = 0; f < i.height; f++) d.push(new Point(i.width - 10, f)) } } else { u = []; for (var f = 0; f < i.height; f++) u.push(new Point(10, f)); d = []; for (var f = 0; f < i.height; f++) d.push(new Point(i.width - 10, f)) } var v, P; if (r.length >= 2) { try { v = n[r[0].index].getPoints(i) } catch (w) { v = []; for (var f = 0; f < i.width; f++) v.push(new Point(f, 10)) } try { P = n[r[r.length - 1].index].getPoints(i) } catch (w) { P = []; for (var f = 0; f < i.width; f++) P.push(new Point(f, i.height - 10)) } if (t.height > t.width) for (var l = t.height; r[r.length - 1].y - r[0].y > .4 * l;) if (l - r[r.length - 1].y > r[0].y) { r.shift(); try { v = n[r[0].index].getPoints(i) } catch (w) { v = []; for (var f = 0; f < i.width; f++) v.push(new Point(f, 10)) } } else { r.pop(); try { P = n[r[r.length - 1].index].getPoints(i) } catch (w) { P = []; for (var f = 0; f < i.width; f++) P.push(new Point(f, i.height - 10)) } } } else { v = []; for (var f = 0; f < i.width; f++) v.push(new Point(f, 10)); P = []; for (var f = 0; f < i.width; f++) P.push(new Point(f, i.height - 10)) } if (t.height < t.width) { if (r.length >= 2 && r[r.length - 1].y - r[0].y < Math.floor(t.height * (2 / 3))) { v = [], P = []; for (var f = 0; f < i.width; f++) v.push(new Point(f, 10)); for (var f = 0; f < i.width; f++) P.push(new Point(f, i.height - 10)) } if (o.length >= 2 && o[o.length - 1].x - o[0].x < Math.floor(t.width * (2 / 3))) { d = [], u = []; for (var f = 0; f < i.height; f++) d.push(new Point(i.width - 10, f)); for (var f = 0; f < i.height; f++) u.push(new Point(10, f)) } } var c, p = [], M = [{ x: 0, y: 0 }, { x: 0, y: 0 }], m = [{ x: 0, y: 0 }, { x: 0, y: 0 }]; t1 = (new Date).getTime(), M[0].x = u[0].x, M[0].y = u[0].y, M[1].x = u[u.length - 1].x, M[1].y = u[u.length - 1].y, m[0].x = v[0].x, m[0].y = v[0].y, m[1].x = v[v.length - 1].x, m[1].y = v[v.length - 1].y, c = getXPoint(M, m); var I = { x: c.x, y: c.y, width: i.width, height: i.height }; isNaN(c.x) || outRange(I) ? p.push(new Point(10, 10)) : p.push(new Point(c.x, c.y)), M[0].x = u[0].x, M[0].y = u[0].y, M[1].x = u[u.length - 1].x, M[1].y = u[u.length - 1].y, m[0].x = P[0].x, m[0].y = P[0].y, m[1].x = P[P.length - 1].x, m[1].y = P[P.length - 1].y, c = getXPoint(M, m); var I = { x: c.x, y: c.y, width: i.width, height: i.height }; isNaN(c.x) || outRange(I) ? p.push(new Point(10, i.height - 10)) : p.push(new Point(c.x, c.y)), M[0].x = d[0].x, M[0].y = d[0].y, M[1].x = d[d.length - 1].x, M[1].y = d[d.length - 1].y, m[0].x = v[0].x, m[0].y = v[0].y, m[1].x = v[v.length - 1].x, m[1].y = v[v.length - 1].y, c = getXPoint(M, m); var I = { x: c.x, y: c.y, width: i.width, height: i.height }; isNaN(c.x) || outRange(I) ? p.push(new Point(i.width - 10, 10)) : p.push(new Point(c.x, c.y)), M[0].x = d[0].x, M[0].y = d[0].y, M[1].x = d[d.length - 1].x, M[1].y = d[d.length - 1].y, m[0].x = P[0].x, m[0].y = P[0].y, m[1].x = P[P.length - 1].x, m[1].y = P[P.length - 1].y, c = getXPoint(M, m); var I = { x: c.x, y: c.y, width: i.width, height: i.height }; return isNaN(c.x) || outRange(I) ? p.push(new Point(i.width - 10, i.height - 10)) : p.push(new Point(c.x, c.y)), p }, getXPoint = function (t, h) { var i, e, a, n, o, r; return t[0].y == t[1].y ? h[0].x == h[1].x ? (o = h[0].x, r = t[0].y) : (a = (h[0].x - h[1].x) / (h[0].y - h[1].y), n = h[0].x - a * h[0].y, o = a * r + n, r = t[0].y) : t[0].x == t[1].x ? h[0].y == h[1].y ? (o = t[0].x, r = h[0].y) : (a = (h[0].x - h[1].x) / (h[0].y - h[1].y), n = h[0].x - a * h[0].y, o = t[0].x, r = (o - n) / a) : (i = (t[0].x - t[1].x) / (t[0].y - t[1].y), e = t[0].x - i * t[0].y, h[0].y == h[1].y ? (r = h[0].y, o = i * r + e) : h[0].x == h[1].x ? (o = h[0].x, r = (o - e) / i) : (a = (h[0].x - h[1].x) / (h[0].y - h[1].y), n = h[0].x - a * h[0].y, r = (n - e) / (i - a), o = i * r + e)), { x: Math.round(o), y: Math.round(r) } }, LinePoint = function (t, h, i) { this.x = t, this.y = h, this.isVert = i }, HoughLine = function (t, h) { this.theta = t, this.r = h, this.draw = function (t) { var i = t.height, e = t.width, a = t.getContext("2d"), n = a.getImageData(0, 0, t.width, t.height), o = Math.sqrt(2) * Math.max(i, e) / 2, r = e / 2, s = i / 2, g = Math.sin(this.theta), x = Math.cos(this.theta); if (this.theta < .25 * Math.PI || this.theta > .75 * Math.PI) for (var y = 0; i > y; y++) { var u = Math.floor((h - o - (y - s) * g) / x + r); if (e > u && u >= 0) { var d = 4 * (y * t.width + u); n.data[d + 0] = 255, n.data[d + 1] = 0, n.data[d + 2] = 0, n.data[d + 3] = 255 } } else if (.45 * Math.PI < this.theta && this.theta < .55 * Math.PI) for (var u = 0; e > u; u++) { var y = Math.floor((h - o - (u - r) * x) / g + s); if (i > y && y >= 0) { var d = 4 * (y * t.width + u); n.data[d + 0] = 255, n.data[d + 1] = 0, n.data[d + 2] = 0, n.data[d + 3] = 255 } } return a.putImageData(n, 0, 0), console.log(t.toDataURL("image/jpeg")), t }, this.getPoints = function (t) { var i = [], e = t.height, a = t.width, n = t.getContext("2d"), o = (n.getImageData(0, 0, t.width, t.height), Math.sqrt(2) * Math.max(e, a) / 2), r = a / 2, s = e / 2, g = Math.sin(this.theta), x = Math.cos(this.theta); if (this.theta < .25 * Math.PI || this.theta > .75 * Math.PI) for (var y = 0; e > y; y++) { var u = Math.floor((h - o - (y - s) * g) / x + r); a > u && u >= 0 && i.push(new LinePoint(u, y, !0)) } else if (.45 * Math.PI < this.theta && this.theta < .55 * Math.PI) for (var u = 0; a > u; u++) { var y = Math.floor((h - o - (u - r) * x) / g + s); e > y && y >= 0 && i.push(new LinePoint(u, y, !1)) } return i } }, HoughTransform = function (t, h) { this.neighbourhoodSize = 4, this.maxTheta = 180, this.thetaStep = Math.PI / this.maxTheta, this.width = t, this.height = h, this.houghHeight = Math.floor(Math.sqrt(2) * Math.max(h, t) / 2), this.doubleHeight = 2 * this.houghHeight, this.houghArray = new Array(this.maxTheta); for (var i = 0; i < this.houghArray.length; i++) { this.houghArray[i] = new Array(this.doubleHeight); for (var e = 0; e < this.doubleHeight; e++) this.houghArray[i][e] = 0 } this.centerX = t / 2, this.centerY = h / 2, this.numPoints = 0, this.sinCache = new Array(this.maxTheta), this.cosCache = new Array(this.maxTheta); for (var a = 0; a < this.maxTheta; a++) { var n = a * this.thetaStep; this.sinCache[a] = Math.sin(n), this.cosCache[a] = Math.cos(n) } this.addPoints = function (t) { for (var h = t.getContext("2d"), i = h.getImageData(0, 0, t.width, t.height), e = 0; e < t.height; e++) for (var a = 0; a < t.width; a++) { var n = 4 * (e * t.width + a); if (0 != i.data[n + 0] && 0 != i.data[n + 1] && 0 != i.data[n + 2]) { for (var o = 0; o < this.maxTheta; o++) { var r = Math.floor((a - this.centerX) * this.cosCache[o] + (e - this.centerY) * this.sinCache[o]); r += this.houghHeight, 0 > r || r >= this.doubleHeight || this.houghArray[o][r]++ } this.numPoints++ } } }, this.getLines = function (t) { var h = new Array; if (0 == this.numPoints) return h; for (var i = 0; i < this.maxTheta; i++) t: for (var e = this.neighbourhoodSize; e < this.doubleHeight - this.neighbourhoodSize; e++) if (this.houghArray[i][e] > t) { for (var a = this.houghArray[i][e], n = -1 * this.neighbourhoodSize; n <= this.neighbourhoodSize; n++) for (var o = -1 * this.neighbourhoodSize; o <= this.neighbourhoodSize; o++) { var r = i + n, s = e + o; if (0 > r ? r += this.maxTheta : r >= this.maxTheta && (r -= this.maxTheta), this.houghArray[r][s] > a) continue t } var g = i * this.thetaStep, x = new HoughLine(g, e); h.push(x) } return h } };